@[toc]
## MySQL的客户端／服务器架构

按下<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>S</kbd>可以保存所有文件。 <font face="黑体" color="red">请谨慎使用此功能。</font>
按下<kbd><font face="黑体" color="red">Ctrl</font></kbd>+<kbd><font face="黑体" color="red">Alt</font></kbd>+<kbd><font face="黑体" color="red">Shift</font></kbd>+<kbd><font face="黑体" color="red">S</font></kbd>可以保存所有文件。请谨慎使用此功能。





 1. 启动MySQL服务器程序。
 2. 启动MySQL客户端程序并连接到服务器程序。
 3. 在客户端程序中输入一些命令语句作为请求发送到服务器程序，服务器程序收到这些请求后，会根据请求的内容来操作具体的数据并向客户端返回操作结果。

每一个运行着的程序也被称为一个<kbd><font face="黑体" color=cc0033>进程</font></kbd>，每个进程一个<kbd><font face="黑体" color=cc0033>PID</font></kbd>
MySQL服务器进程的默认名称为<kbd><font face="黑体" color=cc0033>mysqld</font></kbd>， 而我们常用的MySQL客户端进程的默认名称为<kbd><font face="黑体" color=cc0033>mysql</font></kbd>

## MySQL的安装
注意：<kbd><font face="黑体" color=cc0033>一定一定一定</font></kbd>（重要的话说三遍）要记住你把MySQL安装到哪了

### bin目录下的可执行文件（快速打开）
MySQL的安装目录下有一个特别特别重要的<kbd><font face="黑体" color=cc0033>bin</font></kbd>目录，这个目录下存放着许多<kbd><font face="黑体" color=cc0033>可执行文件</font></kbd>
<kbd><font face="黑体" color=cc0033>Windows</font></kbd>中的可执行文件与macOS中的类似，不过都是以<kbd><font face="黑体" color=cc0033>.exe</font></kbd>为扩展名的

如何在<kbd><font face="黑体" color=cc0033>cmd</font></kbd>运行<kbd><font face="黑体" color=cc0033>bin</font></kbd>目录下的可执行文件？

 1. 相对路径
```c
./bin/mysqld
```
 2. 绝对路径
```c
/usr/local/mysql/bin/mysqld
```
但是每次都要输入一长串的地址，<kbd><font face="黑体" color=cc0033>太麻烦了！！</font></kbd>如何解决？<kbd><font face="黑体" color=cc0033>将该bin目录的路径加入到环境变量PATH中</font></kbd>

环境变量<kbd><font face="黑体" color=cc0033>PATH</font></kbd>是一系列路径的集合，各个路径之间使用冒号<kbd><font face="黑体" color=cc0033>:</font></kbd>隔离开，比方说：

```c
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
```
它的意思是：当我在输入一个命令时，系统便会在<kbd><font face="黑体" color=cc0033>/usr/local/bin</font></kbd>、<kbd><font face="黑体" color=cc0033>/usr/bin:</font></kbd>、<kbd><font face="黑体" color=cc0033>/bin:</font></kbd>、
<kbd><font face="黑体" color=cc0033>/usr/sbin</font></kbd>、<kbd><font face="黑体" color=cc0033>/sbin</font></kbd>这些目录下依次寻找是否存在我们输入的那个命令，如果寻找成功，则执行该目录下对应的可执行文件。

所以我们现在可以修改一下这个环境变量PATH，把MySQL安装目录下的bin目录的路径也加入到PATH中，修改后为：

```c
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/mysql/bin
```
这样现在不论我们所处的工作目录是什么，我们都可以直接输入可执行文件的名字就可以启动它，比如这样：

```c
mysqld
```
## 启动MySQL服务器程序
### Windows里启动服务器程序
在MySQL安装目录下的bin目录下有一个<kbd><font face="黑体" color=cc0033>mysqld</font></kbd>可执行文件，在<kbd><font face="黑体" color=cc0033>命令行（CMD）</font></kbd>里输入
<kbd><font face="黑体" color=cc0033>mysqld（这是添加了PATH之后的操作）</font></kbd>，或者直接双击运行它就算启动了MySQL服务器程序了

### 以服务的方式运行服务器程序（长时间运行、自动启动）
把某个程序注册为Windows服务的方式挺简单，如下：

```c
"完整的可执行文件路径" --install [-manual] [服务名]
```
其中的<kbd><font face="黑体" color=cc0033>-manual</font></kbd>可以省略，加上它的话，表示在Windows系统启动的时候<kbd><font face="黑体" color=cc0033>不</font></kbd>自动启动该服务，否则会自动启动。<kbd><font face="黑体" color=cc0033>服务名</font></kbd>也可以省略，默认的服务名就是
<kbd><font face="黑体" color=cc0033>MySQL</font></kbd>。比如我的Windows计算机上mysqld的完整路径是：

```c
C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqld
```
所以如果我们想把它注册为服务的话可以在命令行里这么写：

```c
"C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqld" --install
```
在把mysqld注册为Windows服务之后，我们就可以通过下面这个命令来启动MySQL服务器程序了：

```c
net start MySQL
```
停止MySQL服务器程序：

```c
net stop MySQL
```



## 启动MySQL客户端程序
成功启动MySQL服务器程序后，就可以接着启动客户端程序来连接到这个服务器喽，bin目录下有许多客户端程序，比方说<kbd><font face="黑体" color=cc0033>mysqladmin、mysqldump、mysqlcheck</font></kbd>等等，我们<kbd><font face="黑体" color=cc0033>重点要关注</font></kbd>的是<kbd><font face="黑体" color=cc0033>mysql</font></kbd>可执行文件，通过这个可执行文件可以让我们和服务器程序进程交互，也就是发送请求，接收服务器的处理结果。
```c
mysql -h主机名  -u用户名 -p密码
```

参数名  | 含义
-------- | -----
<kbd><font face="黑体" color=cc0033>-h</font></kbd>  | 表示服务器进程所在计算机的域名或者IP地址，如果服务器进程就运行在本机的话，可以省略这个参数，或者填<kbd><font face="黑体" color=cc0033>localhost或者127.0.0.1</font></kbd>。也可以写作 <kbd><font face="黑体" color=cc0033>--host=主机名</font></kbd>的形式。
<kbd><font face="黑体" color=cc0033>-u</font></kbd>  | 表示用户名。也可以写作 <kbd><font face="黑体" color=cc0033>--user=用户名</font></kbd>的形式。
<kbd><font face="黑体" color=cc0033>-p</font></kbd>  | 表示密码。也可以写作 <kbd><font face="黑体" color=cc0033>--password=密码</font></kbd>的形式。

比如我这样执行下面这个可执行文件（用户名密码按你的实际情况填写），就可以启动MySQL客户端，并且连接到服务器了。

```c
mysql -hlocalhost -uroot -p123456
```
正常情况下出现：

```c
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 2
Server version: 5.7.21 Homebrew

Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> 
```
如果我们想断开客户端与服务器的连接并且关闭客户端的话，可以在mysql>提示符后输入下面任意一个命令：

```c
1. `quit`
2. `exit`
3. `\q`
```
可以运行多个客户端程序，每个客户端程序都是互不影响的

==注意事项：==

 - 最好不要在一行命令中输入密码：
    - 我们直接在黑框框里输入密码很可能被别人看到，应该这样：
    - `mysql -hlocahhost -uroot -p`
    - 点击回车之后才会提示你输入密码：
    - `Enter password:`
    - 
  - 如果你非要在一行命令中显式的把密码输出来，那-p和密码值之间不能有空白字符（其他参数名之间可以有空白字符），就像这样：
    - `mysql -h localhost -u root -p123456`
  - mysql的各个参数的摆放顺序没有硬性规定，也就是说你也可以这么写：
    - `mysql -u root -p  `
## 客户端与服务器连接的过程
<kbd><font face="黑体" color=cc0033>本质上是一个进程间通信的过程</font></kbd>

### TCP/IP
==TCP==是通信协议，==IP==是每个计算机的唯一地址，==端口号==是一个整数值，它的取值范围是0~65535

比如我们现在已经在本机启动了服务器进程，监听的端口号为3307，那我们启动客户端程序时可以这样写：
```c
mysql -h127.0.0.1 -uroot -P3307 -p
```
### 命名管道和共享内存（看不懂可以先放着）

 1. 使用<kbd><font face="黑体" color=cc0033>命名管道</font></kbd>来进行进程间通信
     - 一种进程间通信机制，在不同的进程之间使用，双向通信
     - <kbd><font face="黑体" color=cc0033>同一台计算机上的进程间通信，不能用于在网络中传输数据</font></kbd>。
     - ==操作==：需要在启动服务器程序的命令中加上<kbd><font face="黑体" color=cc0033>--enable-named-pipe</font></kbd>参数，然后在启动客户端程序的命令中加入<kbd><font face="黑体" color=cc0033>--pipe</font></kbd>或者<kbd><font face="黑体" color=cc0033>--protocol=pipe</font></kbd>参数。
 2. 使用<kbd><font face="黑体" color=cc0033>共享内存</font></kbd>来进行进程间通信
    - 一种进程间通信机制，在不同的进程之间使用，双向通信
    - <kbd><font face="黑体" color=cc0033>同一台计算机上的进程间通信，不能用于在网络中传输数据</font></kbd>。
    - 在共享内存机制中，当一个进程往共享内存区域写入数据时，其他进程可以<kbd><font face="黑体" color=cc0033>直接从该内存区域读取这些数据</font></kbd>，而<kbd><font face="黑体" color=cc0033>无需</font></kbd>将数据从一个进程<kbd><font face="黑体" color=cc0033>复制</font></kbd>到另一个进程或通过其他方式进行传输。
    - ==操作==：需要在启动服务器程序的命令中加上<kbd><font face="黑体" color=cc0033>--shared-memory</font></kbd>参数，在成功启动服务器后，共享内存便成为本地客户端程序的默认连接方式，不过我们也可以在启动客户端程序的命令中加入<kbd><font face="黑体" color=cc0033>--protocol=memory</font></kbd>参数来显式的指定使用共享内存进行通信。

### 服务器处理客户端请求
其实不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：<kbd><font face="黑体" color=cc0033>客户端进程向服务器进程发送一段文本（MySQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）</font></kbd>。那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？客户端可以向服务器发送增删改查各类请求，我们这里以比较复杂的查询请求为例来画个图展示一下大致的过程（服务器做了什么的图）：
![在这里插入图片描述](https://img-blog.csdnimg.cn/9cfc5a13fcc64f9fbb55cd36ef1ff825.png#pic_center)


#### 连接管理（线程创建、销毁，安全性）
客户端进程可以采用我们上面介绍的<kbd><font face="黑体" color=cc0033>TCP/IP、命名管道或共享内存、Unix域套接字（没写，windows不用）</font></kbd>这几种方式之一来与服务器进程建立连接，每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，<kbd><font face="黑体" color=cc0033>服务器并不会立即把与该客户端交互的线程销毁掉</font></kbd>，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频繁创建和销毁线程的效果，从而<kbd><font face="黑体" color=cc0033>节省开销</font></kbd>。从这一点大家也能看出，MySQL服务器会为每一个连接进来的客户端分配一个线程，但是<kbd><font face="黑体" color=cc0033>线程分配的太多了会严重影响系统性能</font></kbd>，所以我们也需要限制一下可以同时连接到服务器的客户端数量，至于怎么限制我们后边再说～

在客户端程序发起连接的时候，需要携带<kbd><font face="黑体" color=cc0033>主机信息、用户名、密码</font></kbd>，服务器程序会对客户端程序提供的这些信息进行认证，如果认证失败，服务器程序会拒绝连接。另外，如果客户端程序和服务器程序不运行在一台计算机上，我们还可以<kbd><font face="黑体" color=cc0033>采用使用了SSL（安全套接字）的网络</font></kbd>连接进行通信，来保证数据传输的<kbd><font face="黑体" color=cc0033>安全性</font></kbd>。

当连接建立后，与该客户端关联的服务器线程会一直等待客户端发送过来的请求，MySQL服务器接收到的请求只是一个文本消息，该文本消息还要经过各种处理，预知后事如何，继续往下看～

#### 解析与优化
到现在为止，MySQL服务器已经获得了文本形式的请求，接着还要经过九九八十一难的处理，其中的几个比较重要的部分分别是<kbd><font face="黑体" color=cc0033>查询缓存、语法解析和查询优化</font></kbd>

##### 查询缓存（类似共享内存）
跟共享内存的作用相似，会把刚刚处理过的查询请求和结果<kbd><font face="黑体" color=cc0033>缓存</font></kbd>起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了，就不用再傻呵呵的去底层的表中查找了。

当然，MySQL服务器并没有人聪明，<kbd><font face="黑体" color=cc0033>如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中</font></kbd>。另外，<kbd><font face="黑体" color=cc0033>如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存</font></kbd>。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数<kbd><font face="黑体" color=cc0033>NOW</font></kbd>，每次调用都会产生最新的当前时间。

不过既然是缓存，那就有它缓存失效的时候。<kbd><font face="黑体" color=cc0033>MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了INSERT、 UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE或 DROP DATABASE语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！</font></kbd>

##### 语法解析（编译过程）
如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本而已，所以MySQL服务器程序首先要对这段文本做分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到MySQL服务器内部使用的一些数据结构上来。

小贴士：这个从指定的文本中提取出我们需要的信息本质上算是一个<kbd><font face="黑体" color=cc0033>编译过程</font></kbd>，涉及词法解析、语法分析、语义分析等阶段，这些问题不属于我们讨论的范畴，大家只要了解在处理请求的过程中需要这个步骤就好了。


##### 查询优化（对菜鸡的垃圾代码进行自动优化）
编译之后，服务器程序获得到了需要的信息，但光有这些是不够的！<kbd><font face="黑体" color=cc0033>因为我们写的MySQL语句执行起来效率可能并不是很高</font></kbd>，MySQL的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接等等的一堆东西。<kbd><font face="黑体" color=cc0033>优化的结果就是生成一个执行计划</font></kbd>，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是什么样的。我们<kbd><font face="黑体" color=cc0033>可以使用EXPLAIN语句来查看某个语句的执行计划</font></kbd>，关于查询优化这部分的详细内容我们后边会仔细介绍，现在你只需要知道在MySQL服务器程序处理请求的过程中有这么一个步骤就好了。

#### 存储引擎
截止到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表，MySQL服务器把数据的存储和提取操作都封装到了一个叫<kbd><font face="黑体" color=cc0033>存储引擎</font></kbd>的模块里。我们知道<kbd><font face="黑体" color=cc0033>表</font></kbd>是由一行一行的记录组成的，<kbd><font face="黑体" color=cc0033>但这只是一个逻辑上的概念</font></kbd>，<kbd><font face="黑体" color=cc0033>物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是存储引擎负责的事情</font></kbd>。为了实现不同的功能，<u>MySQL提供了各式各样的存储引擎，不同存储引擎管理的表具体的存储结构可能不同，采用的存取算法也可能不同。</u>

为了管理方便，人们把<kbd><font face="黑体" color=cc0033>连接管理、查询缓存、语法解析、查询优化</font></kbd>这些并不涉及真实数据存储的功能划分为<kbd><font face="黑体" color=cc0033>MySQL server</font></kbd>的功能，把真实存取数据的功能划分为<kbd><font face="黑体" color=cc0033>存储引擎</font></kbd>的功能。各种不同的存储引擎向上面的MySQL server层提供统一的调用接口（也就是存储引擎<kbd><font face="黑体" color=cc0033>API</font></kbd>），包含了几十个底层函数，像"读取索引第一条内容"、"读取索引下一条内容"、"插入记录"等等。

所以在<kbd><font face="黑体" color=cc0033>MySQL server</font></kbd>完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。

##### 常用存储引擎
存储引擎|描述
--|--
ARCHIVE|用于数据存档（行被插入后不能再修改）
BLACKHOLE|丢弃写操作，读操作会返回空内容
CSV|在存储数据时，以逗号分隔各个数据项
FEDERATED|用来访问远程表
InnoDB|具备外键支持功能的事务存储引擎
MEMORY|置于内存的表
MERGE|用来管理多个MyISAM表构成的表集合
MyISAM|主要的非事务处理存储引擎
NDB|MySQL集群专用存储引擎

其实我们最常用的就是<kbd><font face="黑体" color=cc0033>InnoDB和MyISAM</font></kbd>，有时会提一下<kbd><font face="黑体" color=cc0033>Memory</font></kbd>。其中InnoDB是MySQL默认的存储引擎，我们之后会详细介绍这个存储引擎的各种功能。

关于存储引擎对于某些功能的支持情况，这玩意儿很复杂。其实这些东西大家没必要立即就给记住。

##### 关于存储引擎的一些操作

 - 查看当前服务器程序支持的存储引擎
    - `SHOW ENGINES;`
    - 调用效果：
```c
mysql> SHOW ENGINES;
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
9 rows in set (0.00 sec)
mysql>


- 其中的Support列表示该存储引擎是否可用，DEFAULT值代表是当前服务器程序的默认存储引擎。
- Comment列是对存储引擎的一个描述，英文的，将就着看吧。
- Transactions列代表该存储引擎是否支持事务处理。XA列代表该存储引擎是否支持分布式事务。
- Savepoints代表该列是否支持部分事务回滚。
```
  
 2. 设置表的存储引擎
    -  我们前面说过，存储引擎是负责对表中的数据进行提取和写入的，我们<kbd><font face="黑体" color=cc0033>可以为不同的表设置不同的存储引擎</font></kbd>，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。
    1. 创建表时指定存储引擎
       - 我们之前创建表的语句都没有指定表的存储引擎，那就会使用<kbd><font face="黑体" color=cc0033>默认的存储引擎InnoDB</font></kbd>（当然这个默认的存储引擎也是可以修改的，我们在后边的章节中再说怎么改）。如果我们想显式的指定一下表的存储引擎，那可以这么写：
```c
CREATE TABLE 表名(
    建表语句;
) ENGINE = 存储引擎名称;
```
             - 比如我们想创建一个存储引擎为MyISAM的表可以这么写：

```c
mysql> CREATE TABLE engine_demo_table(
    ->     i int
    -> ) ENGINE = MyISAM;
Query OK, 0 rows affected (0.02 sec)

mysql>
```
          2. 修改表的存储引擎
             - 如果表已经建好了，我们也可以使用下面这个语句来修改表的存储引擎：
```c
ALTER TABLE 表名 ENGINE = 存储引擎名称;
```
             - 比如我们修改一下engine_demo_table表的存储引擎：
```c
mysql> ALTER TABLE engine_demo_table ENGINE = InnoDB;
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql>
```

